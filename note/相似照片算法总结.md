## 相似照片算法功能总结

### **1.1相似照片判定 hash一致性算法**

度量两张图片的相似度有许多算法，下面要介绍的是工程领域中最常用的图片相似度算法之一**——Hash算法**。

Hash算法准确的说有三种，分别为**平均哈希算法(aHash)、感知哈希算法(pHash)和差异哈哈希算法(dHash)**。

三种Hash算法都是通过获取图片的hash值，再比较两张图片hash值的 **汉明距离** 来度量两张图片是否相似。两张图片越相似，那么两张图片的hash数的汉明距离越小。下面本文将分别介绍一下这三种Hash算法。

#### 1 平均哈希算法（aHash）
##### 1.1 算法步骤
平均哈希算法是三种Hash算法中最简单的一种，它通过下面几个步骤来获得图片的Hash值，这几个步骤分别是 **(1) 缩放图片；（2）转灰度图; (3) 算像素均值；（4）根据相似均值计算指纹。** 具体算法如下所示:


##### aHash得到图片Hash值地算法

|步骤|具体内容|
|--------|:-----|
|缩放图片	|输入图片大小尺寸各异，为了统一图片的输入，统一将图片尺寸缩放为8*8，一共得到了64个像素点。|
|转灰度图	|输入图片有些为单通道灰度图，有些RGB三通道彩色图，有些为RGBA四通道彩色图。也为了统一下一步输入标准，将非单通道图片都转为单通道灰度图。 其中RGB三通道转单通道算法有下面几种: <br> 1.浮点算法：Gray=R0.3+G0.59+B0.11; <br> 2.整数方法：Gray=(R30+G59+B11)/100; <br> 3.移位方法：Gray =(R76+G151+B*28)>>8; <br> 4.平均值法：Gray=（R+G+B）/3; <br> 5.仅取绿色：Gray=G;|
|算像素均值|	通过上一步可得一个8x8的整数矩阵G，计算这个矩阵中所有元素的平均值，假设其值为a|
|据像素均值计算指纹	|初始化输入图片的ahash = "" <br>  从左到右一行一行地遍历矩阵G每一个像素如果第i行j列元素G(i,j) >= a，则ahash += "1"如果第i行j列元素G(i,j) <a， 则ahash += "0"得到图片的ahash值后，比较两张图片ahash值的汉明距离，通常认为汉明距离小于10的一组图片为相似图片。|

  得到图片的ahash值后，比较两张图片ahash值的汉明距离，通常认为[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)小于10的一组图片为相似图片。

##### 以下面这张图为例，以图片实例体现过程：    

<div align="center">
       <img src="./相似照片算法总结/aHash/Lena(Origin)图.png"  alt="(Origin)图" />
    </div>  

上图为原图;

<div align="center">
           <img src="./相似照片算法总结/aHash/转为8x8尺寸的Lena图.png"  alt="转为8x8尺寸的Lena图" />
        </div>  

上图为转为8x8尺寸的Lena图;   

<div align="center">
                   <img src="./相似照片算法总结/aHash/ 转为灰度8x8尺寸的Lena图.png"  alt="转为灰度8x8尺寸的Lena图" />
                </div>  

上图为转为灰度8x8尺寸的Lena图;  

其中转为8x8尺寸的Lena对应的数据矩阵为:

 <div align="center">
                    <img src="./相似照片算法总结/aHash/8x8尺寸的Lena对应的数据矩阵.png"  alt="数据矩阵" />
                 </div>  

很容得到如上矩阵 **所有元素的均值a= 121.328125** , 将上述矩阵中大于或等于a的元素置为1, 小于a的元素置为0，可得：

 <div align="center">
                    <img src="./相似照片算法总结/aHash/aHash矩阵.png"  alt="数据矩阵" />
                 </div>  

 所以可得Lena图的aHash为：

***1011111010011110100111011010100110101011101000110000111000101100***

将二进制形式ahash转十六进制hash为：

***be9e9da9aba30e2c***

**为了测试aHash算法的效果，我们用一张带噪声Lena(noise)图和与Lena不一样的Barbara做图片相似度对比实验，其中Lena(noise)和Barbara如下:**

<div align="center">
                   <img src="./相似照片算法总结/aHash/Lena(noise)图.png"  alt="Lena(noise)图" />
                </div>  

上图为Lena(noise)图;  

<div align="center">
                   <img src="./相似照片算法总结/aHash/Barbara图.jpg"  alt="Barbara图" />
                </div>  

上图为Barbara图;  

 **通过aHash算法容易得三个图片的hash值，然后根据hanming距离计算Lena(origin).png和Lena(noise).png Barbar.png之间汉明距离，具体如下:**

<div align="center">
                   <img src="./相似照片算法总结/aHash/aHash算法图片相似度实验.png"  alt="aHash算法图片相似度实验" />
                </div>  

以上为aHash算法的实现流程。


#### 2 感知哈希算法（pHash）

##### 2.1 算法步骤
感知哈希算法是三种Hash算法中较为复杂的一种，它是基于DCT（离散余弦变换）来得到图片的hash值，其算法几个步骤分别是：**(1) 缩放图片；（2）转灰度图; (3) 计算DCT；（4）缩小DCT; (5)算平均值；(6) 计算指纹。** 具体算法如下所示:

表2 pHash得到图片Hash值地算法

|步骤	|具体内容|
|--------|:-----|
|缩放图片|	统一将图片尺寸缩放为32*32，一共得到了1024个像素点。|
|转灰度图|	统一下一步输入标准，将非单通道图片都转为单通道灰度图。|
|计算DCT|	计算32x32数据矩阵的离散余弦变换后对应的32x32数据矩阵|
|缩小DCT	|取上一步得到32x32数据矩阵左上角8x8子区域|
|算平均值	|通过上一步可得一个8x8的整数矩阵G, 计算这个矩阵中所有元素的平均值，假设其值为a|
|计算指纹	|初始化输入图片的phash = ""， <br>从左到右一行一行地遍历矩阵G每一个像素， <br> 如果第i行j列元素G(i,j) >= a，则phash += "1" <br> 如果第i行j列元素G(i,j) <a， 则phash += "0"|


得到图片的phash值后，比较两张图片phash值的汉明距离，通常认为汉明距离小于10的一组图片为相似图片。

##### 2.2 具体实例
仍用之前的图来说明.

<div align="center">
                   <img src="./相似照片算法总结/pHash/转为灰度32x32尺寸的Lena图.png"  alt="灰度32x32尺寸的Lena图" />
                </div>  
转为灰度32x32尺寸的Lena图  

<div align="center">
                   <img src="./相似照片算法总结/pHash/灰度32x32尺寸Lena图对应的DCT矩阵.png"  alt="灰度32x32尺寸Lena图对应的DCT矩阵" />
                </div>  
灰度32x32尺寸Lena图对应的DCT矩阵  

通过计算可得灰度32x32Lenna图对应的DCT矩阵左上角8x8区域子矩阵为:

<div align="center">
                 <img src="./相似照片算法总结/pHash/DCT矩阵左上角8x8区域子矩阵为.png"  alt="灰度32x32尺寸Lena图对应的DCT矩阵" />
                </div>  
很容得到如上矩阵所有元素的均值a= 77.35, 将上述矩阵中大于或等于a的元素置为1, 小于a的元素置为0，可得：

<div align="center">
                 <img src="./相似照片算法总结/pHash/pHash矩阵.png"  alt="灰度32x32尺寸Lena图对应的DCT矩阵" />
                </div>   
所以可得Lena图的pHash为:  

**1001100111000100010101000010010101100000001000111000001010000000**  

将二进制形式phash转十六进制hash为:  

**99c4542560238280**  

为了测试pHash算法的效果，同样用一张带噪声Lena(noise)图和与Lena不一样的Barbara做图片相似度对比实验。通过pHash算法容易得三个图片的hash值，然后根据hanming距离计算Lena(origin).png和Lena(noise).png Barbar.png之间汉明距离，具体如下:
<div align="center">
                 <img src="./相似照片算法总结/pHash/pHash算法图片相似度实验.png"  alt="pHash算法图片相似度实验" />
                </div>  
以上为pHash算法的实现流程。  

------------------------------------

上面总结了在项目中用到的2种图片识别的Hash算法。第三种dHash算法可以点击此链接了解。  
[以上内容大多数转载自此。](https://www.cnblogs.com/Kalafinaian/p/11260808.html)

### **1.2相似照片判定 直方图**

直方图均衡化归类于图像增强的一种图像处理方式。

图像的直方图是衡量图像像素分布的一种方式，可以通过分析像素分布，处理太亮或太暗的图像，通过均衡化处理使用直方图均衡化对图像进行优化，让图像变的清晰。

opencv官方对图像直方图的定义如下：

- 直方图是图像中像素强度分布的图形表达方式.
- 它统计了每一个强度值所具有的像素个数.

#### **一、直方图计算的原理**

一副图像实际上就是一个数字矩阵。

3x3的灰度图像由9个像素组成，每个像素都取值0-255中的一个值，0表示黑色，255表示白色，中间值是介于黑色和白色之间的灰度值。

如下以一个高度为3，宽度为3的图片为例说明直方图的计算。

- 定义一个255大小的数组，用于保存灰度值出现的次数
- 遍历图像的每一个元素，将像素的灰度值出现的次数统计到对应的灰度次数中
- 将灰度值次数统计数组进行归一化处理（归一化到0-255范围内，便于绘图使用）
- 将归一化的灰度次数进行绘图展示

如下图是计算直方图的过程。
![image](https://i.imgur.com/ququLCL.png)

#### **二、直方图计算步骤**
1. 加载图像

2. 定义统计图像三个通道灰度值出现次数和归一化数的数组

  定义并初始化次数数组，按照灰度值255，用于统计每个像素灰度值出现的次数。
  ```
  int histSize = 255;
  int histValues[3][255] = {};
  int histNormalizeValues[3][255] = {};
  for (int k = 0; k < histSize; ++k) {
      histValues[0][k] = 0;
      histValues[1][k] = 0;
      histValues[2][k] = 0;
      histNormalizeValues[0][k] = 0;
      histNormalizeValues[1][k] = 0;
      histNormalizeValues[2][k] = 0;
  }
  ```

3. 遍历图像，计算三个通道灰度值出现的次数

  彩色图像由BGR三个通道构成，分别计算统计这三个通道的灰度值次数。
  ```
  cv::Vec3b rgbPixel;
  // 遍历图像，统计BGR三个通道的图像的灰度值出现的次数
  for (int i = 0; i < rgbImage.rows; ++i) {
     for (int j = 0; j < rgbImage.cols; ++j) {
         // B G R
         rgbPixel = rgbImage.at<cv::Vec3b>(i, j);
         histValues[2][rgbPixel[2]] += 1;
         histValues[1][rgbPixel[1]] += 1;
         histValues[0][rgbPixel[0]] += 1;
     }
  }
  ```
  
4. 将上一步图像灰度值次数归一化到0-255之间
  ```
  // 把如上的统计值归一化到0-255范围内
  calcNormalize(histValues[0], histNormalizeValues[0]);
  calcNormalize(histValues[1], histNormalizeValues[1]);
  calcNormalize(histValues[2], histNormalizeValues[2]);
  ```

### **三、opencv 提供可以直接使用的直方图对比函数式**

  ```
/* Compares two histogram */
CVAPI(double)  cvCompareHist( const CvHistogram* hist1,
                              const CvHistogram* hist2,
                              int method);
  ```

`method` 使用的是`CV_COMP_BHATTACHARYYA` ---- `巴氏距离(Bhattacharyya distance)`


### 2.[**巴氏距离(Bhattacharyya distance)**](https://en.wikipedia.org/wiki/Bhattacharyya_distance)

衡量两个分布之间的距离，表示为
![markdown20191026103211.jpeg](https://i.imgur.com/IeEOHKK.jpg)
其中
对于离散分布
![markdown20191026103230.jpeg](https://i.imgur.com/XiPgjml.jpg)

表示bhattacharyya coefficient，
对于连续分布
![markdown20191026103322.jpeg](https://i.imgur.com/gI4dgIg.jpg)


### 3.离散余弦变换（DCT）

<br>[**一.它是什么?(附带wiki链接)**](https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2)  
离散余弦变换(Discrete Cosine Transform)本质上也是离散傅里叶变换(Discrete Fourier Transform)，但是只有实数部分。**（以下简称DCT）**  

**二.为什么它会出现在这里？**  
DCT可以就是将二维图像从空间域转换到频率域，形象的说，就是计算出图像由哪些二维余弦波构成，计算出的结果为c(u ,v), 其中u为二维波的水平方向频率，v为二维波的垂直方向频率； 最终会计算出很多的c(u,v) ; 每一个c称为一个DCT系数，代表的是频率为(u,v)的二维波的振幅（或者能量），所有这些二维波的叠加就是那个原始的图片。  

**三.怎么用？**  

**二维离散余弦变换可由下列表达式表示:**  

![DCT](./相似照片算法总结/pHash/DCT orgin.png)

这是是二维离散余弦变换的正变换公式，其中f(x,y)是空间域一个N*N的二维向量元素，即一个N*N的矩阵，x,y = 0,1,2，…，N-1;F(U,V)是经计算后得到的变换域矩阵，u,v = 0,1,2，….，N-1.求和可分性是二维离散余弦变换的一个重要特征，因此我们可以用下式表示：  

![DCT](./相似照片算法总结/pHash/DCT.png)

由一维和二维的离散余弦变换公式性质可以推导得到二维离散余弦变换也可以写成矩阵相乘形式

![DCT](./相似照片算法总结/pHash/AUAT.png)

 A为一维离散余弦变换的变换系数矩阵，AT是A的转置矩阵

对图像进行二维离散余弦变换（2D-DCT）的步骤：

 **1.获得图像的二维数据矩阵f(x,y)；**

 **2.求离散余弦变换的系数矩阵A；**

 **3.求系数矩阵对应的转置矩阵AT；**

 **4.根据公式F=A[f(x,y)]AT计算离散余弦变换;**


这便是DCT在图像信号处理中的使用方式。结合上方DCT在pHash算法中的使用过程，我们不难发现，很多图像处理相关功能都少不了它。

**四.使用时的难点在哪？**

1.矩阵转置和矩阵相乘：想要得到DCT后的矩阵那么就必须进行这2种计算，矩阵转置很简单，矩阵的行列互换，但行列式不变。而矩阵相乘就麻烦一些，下面是矩阵乘法的计算方式：

![DCT](./相似照片算法总结/pHash/矩阵乘法.png)

这个计算方式可以用java代码写出来，但是矩阵相乘有三个点需要注意：

**1、当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B可以相乘。**  
**2、矩阵C的行数等于矩阵A的行数，C的列数等于B的列数。**  
**3、乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。**  

基础的计算方式在此就说完了。但是这个计算还是有优化的空间。直接按照该公式写计算逻辑固然简单，但运算消耗也是有的。查阅资料说矩阵相乘计算在C++层有一种更好的通过移位和操作寄存器的计算方式，但是我并没有找到，也没有思路研究出来，在此仅记录一个优化思路。

2.取DCT矩阵左上角8×8的矩阵为结果：这个操作是为什么？原因是傅立叶变换主要是将高频信号转化为低频信号，**理论上** 可以无损地以较小的信息量传输一个对象。~~而实际情况是傅立叶变换是有实数域和复数域的，而因为计算机是在数字环境下工作的，它不可能看见或者处理现实中连续的信号，只能够进行离散计算，在真实性上尽可能地逼近连续信号。所以DCT是舍弃了复数域，并且在DTFT傅立叶级数展开式中，如果被展开的函数是实偶函数，那么其傅立叶级数中只包含余弦项，再将其离散化(DFT)可导出余弦变换，因此称之为离散余弦变换(DCT)。~~所以通俗的来说这是在进行图像的有损压缩，而左上角8×8的矩阵便是其特征向量的集合，也就是压缩后的图片。

**最后总结：傅立叶变换是计算机，网络，通信领域的基石。**

------------------------------------

### 4.实际工程运用中可能遇到的问题  

**通过以上2个章节对理论知识上一些简单的总结，相信大家一定了解了该功能的实现与原理。下面总结一些实际开发中遇到的问题。主要针对于移动端开发，所以总结偏向于用户体验与性能相关。**

##### 1.照片扫描对比时间过长。
虽然说pHash算法相对于aHash算法来说，对比结果更为精确，并且花费的时间肯定更长，但刚开始占用大量开销的点却不在这，而是在于获取照片的缩略图这个步骤。实测中，600张左右的照片，整个过程中花费的时间将近1分钟（机型：MIX 2S 6GB版），90%以上的时间开销在获取照片的缩略图上。所以入手的方向有以下几个：  

 **1.1 减少获取缩略图的时间。**  
首先那肯定是找效果更好的压缩方式，但尝试了很多种效果并不理想。由于开发时间紧张，最终想到直接跳过压缩这一步，取压缩好的照片就行。Android系统中会保存一份相片的缩略图，可以直接调用系统API获得。运行结果直接比之前快了50多秒。但该方式也有明显缺点：1.截屏和其他图片没有系统缩略图;2.该缩略图参数不可调，为系统默认，也就导致识别图源上就有所差异，最后影响精确程度。  

 **1.2 减少图像处理时间。**  
 这方面主要涉及到计算方式的优化，比如说DCT变换过程中矩阵相乘计算在C++层有一种更好的通过移位和操作寄存器的计算方式，虽然当前java层面实现后最终效果也不差，但随着处理图片的数量增加，差距也会越来越明显。

  **1.3 减少图像对比次数。**  
  理论上来说是2层for循环嵌套遍历所有照片并对比，但多数情况下没有必要，因为相似照片基本上能确定产生的时间都在同一个时间段下。于是只要先将所有照片按时间段分组，剔除只有一张照片的组，再对比每组下的相似照片，效率又会高上不少。  

  ##### 2.照片相似度问题。  
  章节一中说到的判定2张照片相似度的方式是判定汉明距离不超过10。这在实际业务中精度还是有一定的差距的，不过这个问题目前并不知道原因所在，实际项目中的判定使用了另一个系数来进行判定，计算该系数的参数为2张照片的修改时间，然而目前并没有查到该系数的说明。

  ##### 3.无法识别的照片
  由于该算法的特性，有以下几种情况的图片并不能很好的识别：  

  **3.1 图片纹理简单的相片**

  **3.2 绘制的图片或2d图像**

  **3.3 原图模糊**
